/*
* @file project_v1.ino
* @author Adam King
* @brief Version 1 implementation of our Feedback Controls project
*
* This code is version 1 of the code used in our Feedback Controls project.
* The code for reading the raw values from the MPU-6050 accelerometer/
* gyroscope sensor was modified from Public Domain code posted by 
* "Arduino User JohnChi". L298N motor driver code was modified from Public
* Domain code posted by "Reichenstein7". All other code based on datasheets
* or workd done by the group, and code was generated by Adam King.
*/

// MPU-6050 Short Example Sketch
// By Arduino User JohnChi
// August 17, 2014
// Public Domain

//I2C communication for the MPU6050 sensor
#include <Wire.h>
const int MPU_addr=0x68;  // I2C address of the MPU-6050

byte noise = 2;
float f32_AY_conversion = 180.0f / 3.14159f / 16384.0f;
float f32_GX_conversion = 1.0f / 131.0f;

short i16_AY_raw, i16_GX_raw; //non-calibrated raw values
double f64_AY_raw_avg, f64_GX_raw_avg; //f64 average of 1000 non-calibrated raw values
short i16_AY_raw_avg, i16_GX_raw_avg; //i16 average of 1000 non-calibrated raw values
float f32_AY_raw_deg_avg, f32_GX_raw_deg_avg; //degrees output from average of 1000 non-calibrated raw values
short i16_AY, i16_GX; //calibrated raw values
float f32_AY_deg, f32_GX_deg; //degrees output from calibrated raw values
float f32_AY_deg_sum, f32_GX_deg_sum;

//Motor driver control
int dir1 = 7;
int dir2 = 8;
boolean useDir1 = true;
int pwm = 9;

//Feedback control constants
float kp = -5.0;
float kd = -0.2;
float ki = 0.0;
float set = 0;
float f32_correction = 0;

//Timing
unsigned long start_time, end_time;

void setup(){
  //For calibration signal
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
  
  //Setup motor driver
  pinMode(dir1, OUTPUT);
  pinMode(dir2, OUTPUT);
  pinMode(pwm, OUTPUT);
  digitalWrite(dir1, LOW);
  digitalWrite(dir2, LOW);
  digitalWrite(pwm, LOW);
  
  //Setup MPU6050
  Wire.begin();
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x6B);  // PWR_MGMT_1 register
  Wire.write(0);     // set to zero (wakes up the MPU-6050)
  Wire.endTransmission(true);
  
  f64_AY_raw_avg = 0.0;
  f64_GX_raw_avg = 0.0;
  f32_GX_deg_sum = 0.0f;
  
  for (int i = 1; i < 1001; i++) {
    Wire.beginTransmission(MPU_addr);
    Wire.write(0x3D);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_addr, 8, true);
    //i16_AY_raw = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise));
    i16_AY_raw = (Wire.read() << 8) | Wire.read();
    Wire.read(); Wire.read();
    Wire.read(); Wire.read();
    //i16_GX_raw = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise)) ;
    i16_GX_raw = (Wire.read() << 8) | Wire.read();
    
    //don't care about speed in calibration for now, so no casting
    //doing this weird averaging so it can still fit within a float
    f64_AY_raw_avg = ((f64_AY_raw_avg * (i - 1)) + i16_AY_raw) / i;
    f64_GX_raw_avg = ((f64_GX_raw_avg * (i - 1)) + i16_GX_raw) / i;
  } //for i
  
  //adding 0.5 and casting to act as rounding
  i16_AY_raw_avg = (short)(f64_AY_raw_avg + 0.5f);
  i16_GX_raw_avg = (short)(f64_GX_raw_avg + 0.5f);
  f32_AY_raw_deg_avg = (float)(f64_AY_raw_avg * (double)f32_AY_conversion);
  f32_GX_raw_deg_avg = (float)(f64_GX_raw_avg / (double)131.0);
  
  
  Serial.begin(115200);
  Serial.println("Averages:");
  Serial.print("  \tf64_AY_raw_avg = "); Serial.print(f64_AY_raw_avg, 4);
  Serial.print("  \tf64_GX_raw_avg = "); Serial.print(f64_GX_raw_avg, 4);
  Serial.println();
  Serial.print("  \ti16_AY_raw_avg = "); Serial.print(i16_AY_raw_avg);
  Serial.print("  \t\ti16_GX_raw_avg = "); Serial.print(i16_GX_raw_avg);
  Serial.println();
  Serial.print("  \tf32_AY_raw_deg_avg = "); Serial.print(f32_AY_raw_deg_avg);
  Serial.print("  \tf32_GX_raw_deg_avg = "); Serial.print(f32_GX_raw_deg_avg);
  Serial.println();
  Serial.println("Setup complete.");
  Serial.flush();
  
  //indicates to the user without a serial terminal that calibration is done
  digitalWrite(LED_BUILTIN, HIGH);
  
  delay(1000);
} //setup

void loop() {
  
  start_time = micros();
  
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x3D);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_addr, 8, true);
  //i16_AY = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise)) -  i16_AY_raw_avg;
  i16_AY = ((Wire.read() << 8) | Wire.read()) - i16_AY_raw_avg;
  Wire.read(); Wire.read();
  Wire.read(); Wire.read();
  //i16_GX = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise)) - i16_GX_raw_avg;
  i16_GX = ((Wire.read() << 8) | Wire.read()) - i16_GX_raw_avg;
  
  //f32_AY = ((float)i16_AY_raw) / 16384.0f;
  f32_AY_deg = ((float)i16_AY) * f32_AY_conversion;
  f32_AY_deg_sum = f32_AY_deg_sum + f32_AY_deg;
  //f32_AY_sum = f32_AY_sum + f32_AY;
  //f32_AY_deg_sum = f32_AY_deg_sum + f32_AY_deg;
  //f32_AY = ((float)i16_GX_raw_sum) / 16384.0f;
  f32_GX_deg = ((float)i16_GX) * f32_GX_conversion;
  f32_GX_deg_sum = f32_GX_deg_sum + f32_GX_deg;
  
  //f32_AY_sum = f32_AY_sum + f32_AY;
  //f32_GX_sum = f32_GX_sum + f32_GX;
  
  //f32_GX_sum_sum = f32_GX_sum_sum + f32_GX_sum;
  
  /*
  Serial.println();
  
  //Serial.print("f32_AY = "); Serial.print(f32_AY, 4);
  Serial.print("  \f32_AY_deg = "); Serial.print(f32_AY_deg, 4);
  Serial.print("  \tf32_AY_deg_sum = "); Serial.print(f32_AY_deg_sum, 4);
  Serial.print("  \tf32_GX_deg = "); Serial.print(f32_GX_deg, 4);
  Serial.print("  \tf32_GX_deg_sum = "); Serial.print(f32_GX_deg_sum, 4);
  */
  
  /*
  Serial.print("  \ti16_AY_raw = "); Serial.print(i16_AY_raw);
  Serial.print("  \t16_GY_raw = "); Serial.print(i16_GX_raw);
  Serial.print("  \ti16_GY_raw_sum = "); Serial.print(i16_GX_raw_sum);
  */
  
  //Serial.println();
  
  f32_correction = 0.0f;
  
  //kp
  f32_correction = f32_correction + (kp * -f32_AY_deg);
  //f32_correction = f32_correction + (kp * f32_GX_deg_sum);
  
  //kd
  f32_correction = f32_correction + (kd * -f32_GX_deg);
  
  //ki
  f32_correction = f32_correction + (ki * -f32_AY_deg_sum);
  //f32_correction = f32_correction + (ki * f32_GX__degsum_sum);
  
  int speed = int((f32_correction / 0.00372549f) + 0.5);
  
  if (speed < 0) {
    useDir1 = true;
  } else {
    useDir1 = false;
  } //if-else
  speed = abs(speed);
  speed = min(speed, 255);
  

  
  if (!useDir1) {
    digitalWrite(dir2, LOW);
    digitalWrite(dir1, HIGH);
  } else {
    digitalWrite(dir1, LOW);
    digitalWrite(dir2, HIGH);
  } //if-else
  //analogWrite(pwm, speed);
  analogWrite(pwm, 0);
  
  end_time = micros();
  
  Serial.print("Time: "); Serial.print(end_time - start_time); Serial.println(" us");
    
  //Serial.print("\tf32_correction = "); Serial.print(f32_correction, 4);
  //Serial.print("\tspeed = "); Serial.print(speed);
  //Serial.print("\tuseDir1 = "); Serial.print(useDir1);
  //Serial.println();
  
  //Serial.flush();
  
  //delay(1);
} //loop
