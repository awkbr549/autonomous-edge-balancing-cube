/*
* @file project_v1.ino
* @author Adam King
* @brief Version 1 implementation of our Feedback Controls project
*
* This code is version 1 of the code used in our Feedback Controls project.
* The code for reading the raw values from the MPU-6050 accelerometer/
* gyroscope sensor was modified from Public Domain code posted by 
* "Arduino User JohnChi". L298N motor driver code was modified from Public
* Domain code posted by "Reichenstein7". All other code based on datasheets
* or workd done by the group, and code was generated by Adam King.
*/

// MPU-6050 Short Example Sketch
// By Arduino User JohnChi
// August 17, 2014
// Public Domain

//I2C communication for the MPU6050 sensor
#include <Wire.h>
const int MPU_addr=0x68;  // I2C address of the MPU-6050

//byte noise = 2;
float factor = 1.0f;
float f32_AY_conversion = factor * 180.0f / 3.14159f / 16384.0f;
float f32_GX_conversion = factor / 131.0f;
float f32_integration_time = 0.00126031f;

short i16_AY_raw, i16_GX_raw; //non-calibrated raw values
double f64_AY_raw_avg, f64_GX_raw_avg; //f64 average of 1000 non-calibrated raw values
short i16_AY_raw_avg, i16_GX_raw_avg; //i16 average of 1000 non-calibrated raw values
float f32_AY_raw_deg_avg, f32_GX_raw_deg_avg; //degrees output from average of 1000 non-calibrated raw values
short i16_AY, i16_GX; //calibrated raw values
int i32_AY_sum, i32_GX_sum, i32_GX_sum_sum;
float f32_AY_deg, f32_GX_deg; //degrees output from calibrated raw values
float f32_AY_deg_sum, f32_GX_deg_sum;

//Motor driver control
int dir1 = 7;
int dir2 = 8;
boolean useDir1 = true;
int pwm = 9;
int maxSpeed = 255;

//Feedback control constants
float kp = -33.0f;
float kd = 0.0f;
float ki = -29.0f;

float f32_correction;
float f32_amp_factor = 0.01245f; //0.00372549f; //0.01245f; //0.00372549f; //needs to change
int speed;

//Timing
unsigned long start_time, end_time;

void setup(){
  //For calibration signal
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
  
  //Setup motor driver
  pinMode(dir1, OUTPUT);
  pinMode(dir2, OUTPUT);
  pinMode(pwm, OUTPUT);
  digitalWrite(dir1, LOW);
  digitalWrite(dir2, LOW);
  digitalWrite(pwm, LOW);
  
  //Setup MPU6050
  Wire.begin();
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x6B);  // PWR_MGMT_1 register
  Wire.write(0);     // set to zero (wakes up the MPU-6050)
  Wire.endTransmission(true);
  
  f64_AY_raw_avg = 0.0;
  f64_GX_raw_avg = 0.0;
  i32_AY_sum = 0;
  i32_GX_sum = 0;
  i32_GX_sum_sum = 0;
  f32_GX_deg_sum = 0.0f;
  
  for (int i = 1; i < 1001; i++) {
    Wire.beginTransmission(MPU_addr);
    Wire.write(0x3D);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_addr, 8, true);
    //Wire.read(); Wire.read();
    //i16_AY_raw = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise));
    i16_AY_raw = (Wire.read() << 8) | Wire.read();
    Wire.read(); Wire.read(); //i16_AZ_raw
    Wire.read(); Wire.read(); //i16_temp_raw
    //i16_GX_raw = ((Wire.read() << 8) | ((Wire.read() >> noise) << noise));
    i16_GX_raw = (Wire.read() << 8) | Wire.read();
    
    //don't care about speed in calibration for now, so no casting
    //doing this weird averaging so it can still fit within a double
    f64_AY_raw_avg = ((f64_AY_raw_avg * (i - 1)) + i16_AY_raw) / i;
    f64_GX_raw_avg = ((f64_GX_raw_avg * (i - 1)) + i16_GX_raw) / i;
  } //for i
  
  //adding 0.5 and casting to act as rounding
  i16_AY_raw_avg = (short)(f64_AY_raw_avg + 0.5f);
  i16_GX_raw_avg = (short)(f64_GX_raw_avg + 0.5f);
  f32_AY_raw_deg_avg = (float)(f64_AY_raw_avg * (double)f32_AY_conversion);
  f32_GX_raw_deg_avg = (float)(f64_GX_raw_avg / (double)131.0);
  
  
  Serial.begin(115200);
  Serial.println("Averages:");
  Serial.print("  \tf64_AY_raw_avg = "); Serial.print(f64_AY_raw_avg, 4);
  Serial.print("  \tf64_GX_raw_avg = "); Serial.print(f64_GX_raw_avg, 4);
  Serial.println();
  Serial.print("  \ti16_AY_raw_avg = "); Serial.print(i16_AY_raw_avg);
  Serial.print("  \t\ti16_GX_raw_avg = "); Serial.print(i16_GX_raw_avg);
  Serial.println();
  Serial.print("  \tf32_AY_raw_deg_avg = "); Serial.print(f32_AY_raw_deg_avg);
  Serial.print("  \tf32_GX_raw_deg_avg = "); Serial.print(f32_GX_raw_deg_avg);
  Serial.println();
  Serial.println("Setup complete.");
  Serial.flush();
  
  //indicates to the user without a serial terminal that calibration is done
  digitalWrite(LED_BUILTIN, HIGH);
  
  delay(1000);
} //setup

void loop() {
  Wire.beginTransmission(MPU_addr);
  Wire.write(0x3D);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_addr, 8, true);
  i16_AY = ((Wire.read() << 8) | Wire.read()) - i16_AY_raw_avg;
  Wire.read(); Wire.read(); //i16_AZ
  Wire.read(); Wire.read(); //i16_temp
  i16_GX = ((Wire.read() << 8) | Wire.read()) - i16_GX_raw_avg;

  i32_AY_sum = i32_AY_sum + (int)i16_AY;
  i32_GX_sum = i32_GX_sum + (int)i16_GX;
  f32_correction = 0.0f;
  f32_correction = (kp * ((float)i32_GX_sum * f32_GX_conversion * f32_integration_time)) + (ki * ((float)i32_AY_sum * f32_AY_conversion * f32_integration_time));

  speed = (int)(f32_correction / f32_amp_factor);
  if (f32_correction < 0.0f) {
    useDir1 = true;
  } else {
    useDir1 = false;
  } //if-else
  if (speed < 0) {
    speed = -speed;
  } //if
  if (speed > maxSpeed) {
    speed = maxSpeed;
  } //if

  if (!useDir1) {
    digitalWrite(dir2, LOW);
    digitalWrite(dir1, HIGH);
  } else {
    digitalWrite(dir1, LOW);
    digitalWrite(dir2, HIGH);
  } //if-else
  analogWrite(pwm, speed);
} //loop
